package main

import "fmt"

func main() {
	v1 := 1
	v2 := v1                               //复制了一份内存
	v1 = 10                                //注意：不支持被修改，相当于重新开启了个，把v1的地址指向了它
	fmt.Printf("v1的内存地址：%p %v\n", &v1, v1) //0x14000110018
	fmt.Printf("v2的内存地址：%p %v\n", &v2, v2) //0x14000110020

	v3 := [2]int{1, 2} //长度为两个数的数组
	v4 := v3           //也会把数组重新创建一次
	v3[0] = 1111
	fmt.Printf("v3的内存地址：%p \n", &v3) //0x14000138000
	fmt.Printf("v4的内存地址：%p \n", &v4) //0x14000138018

	fmt.Printf("%d %d \n\n", v3, v4) //[1111 2] [1 2]

	//切片
	v5 := []int{1, 2}                //定义数组,如果不指定长度就是切片
	v6 := v5                         //
	fmt.Printf("v5的内存地址：%p \n", &v5) //0x140000b6000
	fmt.Printf("v6的内存地址：%p \n", &v6) //0x140000b6018

	v5[0] = 1111 //修改值（内存地址还是一样的）
	//v5 = append(v5, 1111)          //如果是扩容的话，就不是同一个值了，一份数据，又会重新开辟一个内存空间
	fmt.Printf("%d %d \n", v5, v6) //[1111 2] [1 2]

	/**
		 **综上所述，（v4 := v3 ）基础类型都会重新创建一次赋值给新的变量，数据不是同一份了
	     **                    只有切片，虽然地址不一样了，但是数据还是同一份（如果扩容了会导致内存地址不一样了）
	*/

}
