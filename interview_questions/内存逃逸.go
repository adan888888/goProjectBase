package main

import "fmt"

/*
1.什么是内存逃逸？
	内存逃逸（Escape）指本应分配在栈上的变量被编译器判定为必须放到堆上。
	因为栈上的内存会随着函数返回而回收，而某些变量在函数返回后仍然会被引用，因此必须放到堆上让 GC 管理。
2.对内存管理的理解，
	Go 编译器通过 逃逸分析（escape analysis）决定变量分配在栈还是堆。
	比如：堆栈的区别；栈上的内存分配和释放由编译器自动管理，速度快但空间有限；
	堆上的内存分配需要运行时系统的参与，相对较慢但空间较大，由 GC 回收。
3.内存逃逸的影响是什么？（面试重点）
	1. 增加 GC 压力(堆分配意味着需要由垃圾回收器管理 → GC 越频繁，延迟和 CPU 消耗越高。)
	2. 性能下降(栈分配非常快，而堆分配需要,Gc跟踪，Cc回收，→ 开销远大于栈。）
    3. 潜在的内存泄漏风险（长生命周期对象引用短生命周期对象，会导致短生命周期对象不能被回收。）
*/

// 1指针,slice和map作为返回值
// （无法以确定何时引用和释放，因此编译器会将该数据分配在堆上，并使其逃逸当前函数作用域）
func f1() (*int, []int, map[int]int) {
	var i = 0
	list := []int{1, 2, 3, 4}
	maps := map[int]int{1: 1, 2: 2}
	return &i, list, maps
}

// 向chan中发送数据的指针或者包含指针的值
// 编译器此时不知道什么时候被接收，因此只能放在堆中
func f2() {
	var i = 2
	ch := make(chan *int, 2) //chan会被销毁但是里面的值，可能被其它协程引用。 它的生命周期超出了这个函数。
	ch <- &i
}

// 闭包引用外部变量
// 非直接的函数调用， 比如在闭包中引用包外的值，因为闭包的生命周期可能会超过函数的周期，因此需要放入堆中
func f3() func() {
	var i = 1
	return func() {
		fmt.Println(i)
	}
}

// 动态大小的 slice/map、较大的 struct 可能直接分配到堆。
func f4() {
	list := make([]*int, 10)
	fmt.Println(list)
}

// 变量被接口引用
// 接口引用需要存储在堆上，尤其在动态类型不确定时。
func f5() interface{} {
	x := 10
	return x // 逃逸
}

//变量传递给不确定生命周期的函数
//fmt.Println(x)   // 不逃逸
//go func(){...}( ) // 逃逸

func main() {
	f2()
}

/*
4. 如何避免逃逸？（面试官很喜欢问）

✔ 1. 尽量避免返回局部变量的指针

改为返回值，而非返回指针。

✔ 2. 尽量避免接口类型（interface{}）

interface 容易导致逃逸。

✔ 3. 减少闭包中引用外部变量

特别是在高频调用的函数里。

✔ 4. 参数传递使用指针 vs 值
	•	如果结构体较小，用值传递更好（不会逃逸）
	•	大结构体可以用指针（但要注意逃逸风险）

6. 用一句话总结（面试结尾用）
	内存逃逸本质上是 Go 编译器为了保证变量生命周期安全，将变量从栈分配转到堆分配的行为。
	逃逸会增加 GC 压力，因此我们需要理解逃逸分析并避免不必要的堆分配。

go build -gcflags -m main.go //检测哪些有内存逃逸
*/
